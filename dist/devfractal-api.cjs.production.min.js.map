{"version":3,"file":"devfractal-api.cjs.production.min.js","sources":["../src/http.ts","../src/query.ts","../src/rest.ts"],"sourcesContent":["import ax, { AxiosInstance, AxiosRequestConfig } from 'axios'\nimport { decode } from 'io-ts-promise'\nimport { stringify } from 'query-string'\nimport {\n  array,\n  chop,\n  debug,\n  InputOf,\n  keys,\n  Mixed,\n  ObjC,\n  Props,\n  string,\n  TypeOf,\n  verify,\n} from 'technoidentity-utils'\n\nexport interface MethodArgs {\n  readonly resource?: string\n  readonly path?: string | readonly string[]\n  readonly query?: string | Record<string, any>\n}\n\nfunction slashWarn(s: string): void {\n  verify(string.is(s))\n\n  debug(!s.includes('/'), `${s} should not contain \"/\"`)\n}\nexport interface RequestConfig extends AxiosRequestConfig {\n  readonly baseURL: string\n}\n\nfunction buildResource(resource?: string): string {\n  if (resource !== undefined && resource.trim() !== '') {\n    slashWarn(resource)\n    return `/${resource}`\n  }\n\n  return ''\n}\n\nfunction buildPath(path?: string | readonly string[]): string {\n  if (array(string).is(path)) {\n    const paths: string[] = path.filter(p => p.trim() !== '')\n    paths.forEach(slashWarn)\n    return paths.length === 0 ? '' : `/${paths.join('/')}`\n  }\n\n  if (string.is(path) && path.trim() !== '') {\n    slashWarn(path)\n    return `/${path}`\n  }\n\n  return ''\n}\n\nfunction buildQueryString(query?: string | Record<string, any>): string {\n  return query === undefined || keys(query).length === 0\n    ? ''\n    : `?${string.is(query) ? query : stringify(query)}`\n}\n\nexport function buildUrl(options: MethodArgs): string {\n  return `${buildResource(options.resource)}${buildPath(\n    options.path,\n  )}${buildQueryString(options.query)}`\n}\n\nfunction url(options: MethodArgs | string): string {\n  return string.is(options) ? options : buildUrl(options)\n}\n\n// tslint:disable-next-line: typedef\nexport function http({ baseURL, ...config }: RequestConfig) {\n  const axios: AxiosInstance = ax.create({\n    ...config,\n    baseURL: chop(baseURL),\n  })\n\n  async function get<Spec extends Mixed>(\n    options: MethodArgs | string,\n    responseSpec: Spec,\n  ): Promise<TypeOf<Spec>> {\n    return axios\n      .get<InputOf<Spec>>(url(options))\n      .then(res => res.data)\n      .then(decode(responseSpec))\n  }\n\n  async function post<Spec extends Mixed, ID extends keyof Spec>(\n    options: Omit<MethodArgs, 'query'> | string,\n    data: Omit<InputOf<Spec>, ID>,\n    responseSpec: Spec,\n  ): Promise<TypeOf<Spec>> {\n    return axios\n      .post<InputOf<Spec>>(url(options), data)\n      .then(res => res.data)\n      .then(decode(responseSpec))\n  }\n\n  async function patch<Opt extends Props, Req extends Props>(\n    options: Omit<MethodArgs, 'query'> | string,\n    data: Partial<InputOf<ObjC<Opt, Req>>>,\n    responseSpec: ObjC<Opt, Req>,\n  ): Promise<TypeOf<ObjC<Opt, Req>>> {\n    return axios\n      .patch<InputOf<ObjC<Opt, Req>>>(url(options), data)\n      .then(res => res.data)\n      .then(decode(responseSpec))\n  }\n\n  async function put<Spec extends Mixed>(\n    options: Omit<MethodArgs, 'query'> | string,\n    data: InputOf<Spec>,\n    responseSpec: Spec,\n  ): Promise<TypeOf<Spec>> {\n    return axios\n      .put<InputOf<Spec>>(url(options), data)\n      .then(res => res.data)\n      .then(decode(responseSpec))\n  }\n\n  async function del(\n    options: Omit<MethodArgs, 'query'> | string,\n  ): Promise<void> {\n    return axios.delete(url(options))\n  }\n\n  return { get, del, put, post, patch, axios }\n}\n","import { stringify } from 'query-string'\nimport {\n  AnyObj,\n  cast,\n  getProps,\n  keyof,\n  number,\n  ObjC,\n  opt,\n  partial,\n  Props,\n  readonlyArray,\n  req,\n  string,\n  TypeOf,\n  union,\n} from 'technoidentity-utils'\n\n// tslint:disable typedef\n\nexport const Page = req({ current: number, limit: number })\nconst SliceStartEnd = req({ start: number, end: number })\nconst SliceStartLimit = req({ start: number, limit: number })\nexport const Slice = union([SliceStartEnd, SliceStartLimit])\n\n// const Operators = opt({\n//   gt: Int,\n//   lt: Int,\n//   gte: Int,\n//   lte: Int,\n//   ne: union([Int, string]),\n//   like: string,\n// })\n\nexport interface APIQuery<C> {\n  readonly select?: ReadonlyArray<keyof C>\n  readonly filter?: Partial<C>\n  readonly range?: TypeOf<typeof Page> | TypeOf<typeof Slice>\n  readonly asc?: ReadonlyArray<keyof C>\n  readonly desc?: ReadonlyArray<keyof C>\n  readonly fullText?: string\n  readonly like?: Partial<C>\n  readonly embed?: keyof C\n  // readonly operators?: TypeOf<typeof Operators>\n}\n\nfunction apiQuerySpec(codec: AnyObj) {\n  const props = getProps(codec)\n\n  return opt({\n    select: readonlyArray(keyof(props)),\n    filter: partial(props),\n    range: union([Page, Slice]),\n    asc: readonlyArray(keyof(props)),\n    desc: readonlyArray(keyof(props)),\n    fullText: string,\n    like: partial(props),\n    // operators: record(keys(codec), Operators),\n    embed: keyof(props),\n  })\n}\n\nfunction likeQuery(like?: object): object {\n  const obj = like || {}\n  return Object.keys(obj).reduce<any>((acc, k) => {\n    // tslint:disable-next-line: no-object-mutation\n    acc[`${k}_like`] = obj[k]\n    return acc\n  }, {})\n}\n\nexport function toJSONServerQuery<Opt extends Props, Req extends Props>(\n  codec: ObjC<Opt, Req>,\n  query: APIQuery<TypeOf<typeof codec>>,\n): string {\n  cast(apiQuerySpec(codec), query)\n\n  const range = Page.is(query.range)\n    ? { _page: query.range.current, _limit: query.range.limit }\n    : SliceStartEnd.is(query.range)\n    ? {\n        _start: query.range.start,\n        _end: query.range.end,\n      }\n    : SliceStartLimit.is(query.range)\n    ? { _start: query.range.start, _limit: query.range.limit }\n    : {}\n\n  const { asc, desc } = query\n  const _sort = (asc || []).concat(desc || [])\n\n  const _order = (asc || [])\n    .map(_ => 'asc')\n    .concat((desc || []).map(_ => 'desc'))\n\n  const { filter, fullText: q, embed } = query\n  return stringify(\n    {\n      ...likeQuery(query.like),\n      ...filter,\n      ...range,\n      _sort,\n      _order,\n      q,\n      embed,\n    },\n    { arrayFormat: 'comma' },\n  )\n}\n\nexport function toAPIQuery<Opt extends Props, Req extends Props>(\n  spec: ObjC<Opt, Req>,\n  query: APIQuery<TypeOf<typeof spec>>,\n): string {\n  cast(apiQuerySpec(spec), query)\n\n  const { asc, desc } = query\n\n  const { filter, fullText: q, embed, select } = query\n\n  return stringify(\n    {\n      ...filter,\n      ...(query.range || {}),\n      select,\n      asc,\n      desc,\n      q,\n      embed,\n      ...likeQuery(query.like),\n    },\n    { arrayFormat: 'comma' },\n  )\n}\n","import { produce } from 'immer'\nimport {\n  ObjC,\n  objPick,\n  omit,\n  Props,\n  readonlyArray,\n  TypeOf,\n  UnknownArray,\n} from 'technoidentity-utils'\nimport { http as httpAPI, MethodArgs, RequestConfig } from './http'\nimport { APIQuery, toAPIQuery as toQueryFn } from './query'\n\ntype APIMethodArgs = Omit<MethodArgs, 'resource'>\nexport interface API<\n  Opt extends Props,\n  Req extends Props,\n  ID extends keyof TypeOf<ObjC<Opt, Req>>\n> {\n  readonly http: ReturnType<typeof httpAPI>\n  readonly spec: ObjC<Opt, Req>\n  readonly idKey: ID\n  readonly resource: string\n\n  many(options?: APIMethodArgs): Promise<ReadonlyArray<TypeOf<ObjC<Opt, Req>>>>\n\n  one(options?: APIMethodArgs): Promise<TypeOf<ObjC<Opt, Req>>>\n\n  create(\n    data: Omit<TypeOf<ObjC<Opt, Req>>, ID>,\n    options?: APIMethodArgs,\n  ): Promise<TypeOf<ObjC<Opt, Req>>>\n\n  get(\n    id: TypeOf<ObjC<Opt, Req>>[ID],\n    options?: APIMethodArgs,\n  ): Promise<TypeOf<ObjC<Opt, Req>>>\n\n  list(\n    query: APIQuery<TypeOf<ObjC<Opt, Req>>>,\n    options?: Omit<APIMethodArgs, 'query'>,\n  ): Promise<ReadonlyArray<TypeOf<ObjC<Opt, Req>>>>\n\n  select<K extends keyof TypeOf<ObjC<Opt, Req>>>(\n    query: Omit<APIQuery<TypeOf<ObjC<Opt, Req>>>, 'select'>,\n    select: readonly K[],\n    options?: Omit<APIMethodArgs, 'query'>,\n  ): Promise<\n    ReadonlyArray<\n      TypeOf<\n        ObjC<Pick<Opt, Extract<keyof Opt, K>>, Pick<Req, Extract<keyof Req, K>>>\n      >\n    >\n  >\n\n  replace(\n    id: TypeOf<ObjC<Opt, Req>>[ID],\n    data: TypeOf<ObjC<Opt, Req>>,\n    options?: APIMethodArgs,\n  ): Promise<TypeOf<ObjC<Opt, Req>>>\n\n  update(\n    id: TypeOf<ObjC<Opt, Req>>[ID],\n    data: Partial<TypeOf<ObjC<Opt, Req>>>,\n    options?: APIMethodArgs,\n  ): Promise<TypeOf<ObjC<Opt, Req>>>\n\n  del(id: TypeOf<ObjC<Opt, Req>>[ID], options?: APIMethodArgs): Promise<void>\n}\n\nfunction appendId(options: MethodArgs, id: string): MethodArgs {\n  return produce(options, draft => {\n    if (draft.path === undefined) {\n      draft.path = id\n    } else if (UnknownArray.is(draft.path)) {\n      draft.path.unshift(id)\n    } else {\n      draft.path = [id, draft.path]\n    }\n  })\n}\n\ninterface RestArgs extends RequestConfig {\n  readonly resource: string\n}\n\nexport function rest<\n  Opt extends Props,\n  Req extends Props,\n  ID extends keyof TypeOf<ObjC<Opt, Req>>\n>(\n  spec: ObjC<Opt, Req>,\n  idKey: ID,\n  { resource, ...options }: RestArgs,\n  toQuery: (\n    spec: ObjC<Opt, Req>,\n    query: APIQuery<TypeOf<ObjC<Opt, Req>>>,\n  ) => string = toQueryFn,\n): API<Opt, Req, ID> {\n  const http: ReturnType<typeof httpAPI> = httpAPI(options)\n\n  async function many(\n    options: APIMethodArgs,\n  ): Promise<ReadonlyArray<TypeOf<ObjC<Opt, Req>>>> {\n    return http.get({ ...options, resource }, readonlyArray(spec))\n  }\n\n  async function one(options: APIMethodArgs): Promise<TypeOf<ObjC<Opt, Req>>> {\n    return http.get({ ...options, resource }, spec)\n  }\n\n  async function create(\n    data: Omit<TypeOf<ObjC<Opt, Req>>, ID>,\n    options: APIMethodArgs,\n  ): Promise<TypeOf<ObjC<Opt, Req>>> {\n    // @TODO: Hopefully in future, either we won't omit, or use spec to omit.\n    return http.post({ ...options, resource }, omit(data, [idKey as any]), spec)\n  }\n\n  async function del(\n    id: TypeOf<ObjC<Opt, Req>>[ID],\n    options?: APIMethodArgs,\n  ): Promise<void> {\n    return http.del(appendId({ ...options, resource }, id))\n  }\n\n  async function get(\n    id: TypeOf<ObjC<Opt, Req>>[ID],\n    options: APIMethodArgs,\n  ): Promise<TypeOf<ObjC<Opt, Req>>> {\n    return one(appendId({ ...options, resource }, id))\n  }\n\n  async function list(\n    query: APIQuery<TypeOf<ObjC<Opt, Req>>>,\n    options?: Omit<APIMethodArgs, 'query'>,\n  ): Promise<ReadonlyArray<TypeOf<ObjC<Opt, Req>>>> {\n    return many({ query: toQuery(spec, query), ...options })\n  }\n\n  async function select<K extends keyof TypeOf<ObjC<Opt, Req>>>(\n    query: Omit<APIQuery<TypeOf<ObjC<Opt, Req>>>, 'select'>,\n    select: readonly K[],\n    options?: Omit<APIMethodArgs, 'query'>,\n    // @TODO: LOL at type\n  ): Promise<\n    ReadonlyArray<\n      TypeOf<\n        ObjC<Pick<Opt, Extract<keyof Opt, K>>, Pick<Req, Extract<keyof Req, K>>>\n      >\n    >\n  > {\n    return http.get(\n      { query: toQuery(spec, { ...query, select }), ...options, resource },\n      readonlyArray(objPick(spec, select)),\n    )\n  }\n\n  async function replace(\n    id: TypeOf<ObjC<Opt, Req>>[ID],\n    data: TypeOf<ObjC<Opt, Req>>,\n    options: APIMethodArgs,\n  ): Promise<TypeOf<ObjC<Opt, Req>>> {\n    return http.put(appendId({ ...options, resource }, id), data, spec)\n  }\n\n  async function update(\n    id: TypeOf<ObjC<Opt, Req>>[ID],\n    data: Partial<TypeOf<ObjC<Opt, Req>>>,\n    options: APIMethodArgs,\n  ): Promise<TypeOf<ObjC<Opt, Req>>> {\n    return http.patch(appendId({ ...options, resource }, id), data, spec)\n  }\n\n  return {\n    one,\n    many,\n    replace,\n    update,\n    create,\n    del,\n    get,\n    list,\n    idKey,\n    spec,\n    resource,\n    http,\n    select,\n  }\n}\n"],"names":["slashWarn","s","verify","string","is","debug","includes","buildUrl","options","undefined","resource","trim","path","array","paths","filter","p","forEach","length","join","buildPath","query","keys","stringify","url","http","baseURL","config","axios","ax","create","chop","get","responseSpec","then","res","data","decode","del","put","post","patch","Page","req","current","number","limit","SliceStartEnd","start","end","SliceStartLimit","Slice","union","apiQuerySpec","codec","props","getProps","opt","select","readonlyArray","keyof","partial","range","asc","desc","fullText","like","embed","likeQuery","obj","Object","reduce","acc","k","toAPIQuery","spec","cast","q","arrayFormat","appendId","id","produce","draft","UnknownArray","unshift","idKey","toQuery","one","many","toQueryFn","httpAPI","replace","update","omit","list","objPick","_page","_limit","_start","_end","_sort","concat","_order","map","_"],"mappings":"shBAuBA,SAASA,EAAUC,GACjBC,SAAOC,SAAOC,GAAGH,IAEjBI,SAAOJ,EAAEK,SAAS,KAASL,sCAoCbM,EAASC,eA7BNC,KADIC,EA+BGF,EAAQE,WA9BkB,KAApBA,EAASC,QACrCX,EAAUU,OACCA,GAGN,IAGT,SAAmBE,MACbC,QAAMV,UAAQC,GAAGQ,GAAO,KACpBE,EAAkBF,EAAKG,OAAO,SAAAC,SAAkB,KAAbA,EAAEL,gBAC3CG,EAAMG,QAAQjB,GACU,IAAjBc,EAAMI,OAAe,OAASJ,EAAMK,KAAK,YAG9ChB,SAAOC,GAAGQ,IAAyB,KAAhBA,EAAKD,QAC1BX,EAAUY,OACCA,GAGN,GAUqCQ,CAC1CZ,EAAQI,YAPOH,KADOY,EASHb,EAAQa,QARwB,IAAvBC,OAAKD,GAAOH,OACtC,QACIf,SAAOC,GAAGiB,GAASA,EAAQE,YAAUF,KAH/C,IAA0BA,EAxBHX,EAoCvB,SAASc,EAAIhB,UACJL,SAAOC,GAAGI,GAAWA,EAAUD,EAASC,YAIjCiB,SAAOC,IAAAA,QAAYC,mBAC3BC,EAAuBC,EAAGC,YAC3BH,GACHD,QAASK,OAAKL,YAoDT,CAAEM,aAhDPxB,EACAyB,8BAEOL,EACJI,IAAmBR,EAAIhB,IACvB0B,KAAK,SAAAC,UAAOA,EAAIC,OAChBF,KAAKG,SAAOJ,yCA0CHK,aALZ9B,8BAEOoB,SAAaJ,EAAIhB,yCAGP+B,aAhBjB/B,EACA4B,EACAH,8BAEOL,EACJW,IAAmBf,EAAIhB,GAAU4B,GACjCF,KAAK,SAAAC,UAAOA,EAAIC,OAChBF,KAAKG,SAAOJ,yCASOO,cAtCtBhC,EACA4B,EACAH,8BAEOL,EACJY,KAAoBhB,EAAIhB,GAAU4B,GAClCF,KAAK,SAAAC,UAAOA,EAAIC,OAChBF,KAAKG,SAAOJ,yCA+BaQ,eA3B5BjC,EACA4B,EACAH,8BAEOL,EACJa,MAA+BjB,EAAIhB,GAAU4B,GAC7CF,KAAK,SAAAC,UAAOA,EAAIC,OAChBF,KAAKG,SAAOJ,yCAoBoBL,MAAAA,OC5G1Bc,EAAOC,MAAI,CAAEC,QAASC,SAAQC,MAAOD,WAC5CE,EAAgBJ,MAAI,CAAEK,MAAOH,SAAQI,IAAKJ,WAC1CK,EAAkBP,MAAI,CAAEK,MAAOH,SAAQC,MAAOD,WACvCM,EAAQC,QAAM,CAACL,EAAeG,IAuB3C,SAASG,EAAaC,OACdC,EAAQC,WAASF,UAEhBG,MAAI,CACTC,OAAQC,gBAAcC,QAAML,IAC5BxC,OAAQ8C,UAAQN,GAChBO,MAAOV,QAAM,CAACV,EAAMS,IACpBY,IAAKJ,gBAAcC,QAAML,IACzBS,KAAML,gBAAcC,QAAML,IAC1BU,SAAU9D,SACV+D,KAAML,UAAQN,GAEdY,MAAOP,QAAML,KAIjB,SAASa,EAAUF,OACXG,EAAMH,GAAQ,UACbI,OAAOhD,KAAK+C,GAAKE,OAAY,SAACC,EAAKC,UAExCD,EAAOC,WAAYJ,EAAII,GAChBD,GACN,aA0CWE,EACdC,EACAtD,UAEAuD,OAAKvB,EAAasB,GAAOtD,GAMlBE,iBAFwCF,EAAvCN,UAKAM,EAAMyC,OAAS,IACnBJ,OAN2CrC,EAAXqC,OAOhCK,IATkB1C,EAAd0C,IAUJC,KAVkB3C,EAAT2C,KAWTa,EAT2CxD,EAA/B4C,SAUZE,MAV2C9C,EAAlB8C,OAWtBC,EAAU/C,EAAM6C,OAErB,CAAEY,YAAa,UC7DnB,SAASC,EAASvE,EAAqBwE,UAC9BC,UAAQzE,EAAS,SAAA0E,QACHzE,IAAfyE,EAAMtE,KACRsE,EAAMtE,KAAOoE,EACJG,eAAa/E,GAAG8E,EAAMtE,MAC/BsE,EAAMtE,KAAKwE,QAAQJ,GAEnBE,EAAMtE,KAAO,CAACoE,EAAIE,EAAMtE,sFAS9B,SAKE+D,EACAU,IAEAC,OAaeC,WAAI/E,8BACViB,EAAKO,SAASxB,GAASE,SAAAA,IAAYiE,wCAP7Ba,WACbhF,8BAEOiB,EAAKO,SAASxB,GAASE,SAAAA,IAAYiD,gBAAcgB,yCAXxDjE,IAAAA,SAAaF,6BACf8E,IAAAA,EAGcG,OAERhE,EAAmCiE,EAAQlF,SA2E1C,CACL+E,IAAAA,EACAC,KAAAA,EACAG,iBAlBAX,EACA5C,EACA5B,8BAEOiB,EAAKc,IAAIwC,OAAcvE,GAASE,SAAAA,IAAYsE,GAAK5C,EAAMuC,wCAe9DiB,gBAXAZ,EACA5C,EACA5B,8BAEOiB,EAAKgB,MAAMsC,OAAcvE,GAASE,SAAAA,IAAYsE,GAAK5C,EAAMuC,wCAQhE7C,gBAnEAM,EACA5B,8BAGOiB,EAAKe,UAAUhC,GAASE,SAAAA,IAAYmF,OAAKzD,EAAM,CAACiD,IAAgBV,wCAgEvErC,aA5DA0C,EACAxE,8BAEOiB,EAAKa,IAAIyC,OAAcvE,GAASE,SAAAA,IAAYsE,yCA0DnDhD,aAtDAgD,EACAxE,cAEO+E,EAAIR,OAAcvE,GAASE,SAAAA,IAAYsE,wCAoD9Cc,cAhDAzE,EACAb,cAEOgF,KAAOnE,MAAOiE,EAAQX,EAAMtD,IAAWb,wCA8C9C6E,MAAAA,EACAV,KAAAA,EACAjE,SAAAA,EACAe,KAAAA,EACAiC,gBA9CArC,EACAqC,EACAlD,8BASOiB,EAAKO,OACRX,MAAOiE,EAAQX,OAAWtD,GAAOqC,OAAAA,MAAclD,GAASE,SAAAA,IAC1DiD,gBAAcoC,UAAQpB,EAAMjB,oGDlFhCJ,EACAjC,GAEAuD,OAAKvB,EAAaC,GAAQjC,OAEpByC,EAAQpB,EAAKtC,GAAGiB,EAAMyC,OACxB,CAAEkC,MAAO3E,EAAMyC,MAAMlB,QAASqD,OAAQ5E,EAAMyC,MAAMhB,OAClDC,EAAc3C,GAAGiB,EAAMyC,OACvB,CACEoC,OAAQ7E,EAAMyC,MAAMd,MACpBmD,KAAM9E,EAAMyC,MAAMb,KAEpBC,EAAgB9C,GAAGiB,EAAMyC,OACzB,CAAEoC,OAAQ7E,EAAMyC,MAAMd,MAAOiD,OAAQ5E,EAAMyC,MAAMhB,OACjD,GAEIiB,EAAc1C,EAAd0C,IAAKC,EAAS3C,EAAT2C,KACPoC,GAASrC,GAAO,IAAIsC,OAAOrC,GAAQ,IAEnCsC,GAAUvC,GAAO,IACpBwC,IAAI,SAAAC,SAAK,QACTH,QAAQrC,GAAQ,IAAIuC,IAAI,SAAAC,SAAK,UAExBzF,EAA+BM,EAA/BN,OAAkB8D,EAAaxD,EAAvB4C,SAAaE,EAAU9C,EAAV8C,aACtB5C,iBAEA6C,EAAU/C,EAAM6C,SAChBnD,KACA+C,GACHsC,MAAAA,EACAE,OAAAA,EACAzB,EAAAA,EACAV,MAAAA,IAEF,CAAEW,YAAa"}